<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CamNext — Aleatorio P2P (Auto-match)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <style>
    :root{--accent:#0d6efd}
    body{background:#f6f7fb;}
    .app{max-width:1100px;margin:24px auto}
    .video-wrap{background:#111;border-radius:12px;padding:8px;}
    video{width:100%;height:auto;border-radius:8px;background:#000}
    .user-badge{font-weight:600}
    .chat-box{height:320px;overflow:auto;background:#fff;padding:12px;border-radius:8px;border:1px solid #e6e6e6}
    .small-muted{font-size:.85rem;color:#6c757d}
    .file-item{font-size:.9rem}
  </style>
</head>
<body>
  <div class="container app">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h2 class="mb-0">CamNext <small class="small-muted">— Emparejado automático (demo)</small></h2>
      <div><span id="uidBadge" class="badge bg-secondary user-badge">Generando...</span></div>
    </div>

    <div class="row g-3">
      <div class="col-md-7">
        <div class="video-wrap mb-3">
          <div class="row g-2">
            <div class="col-6">
              <label class="small-muted">Tu cámara</label>
              <video id="localVideo" autoplay muted playsinline></video>
              <div class="d-flex gap-2 mt-2">
                <button id="toggleCam" class="btn btn-sm btn-outline-primary">Cam</button>
                <button id="toggleMic" class="btn btn-sm btn-outline-primary">Mic</button>
                <button id="shareScreen" class="btn btn-sm btn-outline-secondary">Compartir pantalla</button>
              </div>
            </div>
            <div class="col-6">
              <label class="small-muted">Conectado a</label>
              <video id="remoteVideo" autoplay playsinline></video>
              <div class="d-flex gap-2 mt-2">
                <button id="passBtn" class="btn btn-sm btn-danger">Siguiente</button>
                <button id="stopBtn" class="btn btn-sm btn-outline-danger">Desconectar</button>
              </div>
            </div>
          </div>
        </div>

        <div class="card p-3 mb-3">
          <div class="d-flex gap-2 align-items-center">
            <input id="nameInput" class="form-control form-control-sm" placeholder="Tu nombre (opcional)" />
            <button id="saveName" class="btn btn-sm btn-primary">Guardar</button>
            <button id="findBtn" class="btn btn-sm btn-success">Buscar (auto)</button>
          </div>
          <div class="mt-2 small-muted">El sistema intentará emparejarte automáticamente con la primera persona disponible.</div>
        </div>
      </div>

      <div class="col-md-5">
        <div class="card p-3 mb-3">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <strong>Chat & Archivos</strong>
            <small class="small-muted" id="roomLabel">No conectado</small>
          </div>
          <div id="chatBox" class="chat-box mb-2"></div>

          <div class="d-flex gap-2">
            <input id="chatInput" class="form-control form-control-sm" placeholder="Escribí algo..." />
            <button id="sendBtn" class="btn btn-sm btn-primary">Enviar</button>
          </div>

          <div class="d-flex gap-2 mt-2">
            <input type="file" id="fileInput" class="form-control form-control-sm" />
            <button id="sendFileBtn" class="btn btn-sm btn-outline-primary">Enviar archivo</button>
          </div>

          <div class="mt-2 small-muted">En producción reemplazá las claves demo y agregá un TURN confiable.</div>
        </div>

        <div class="card p-3">
          <strong>Estado</strong>
          <div class="mt-2 small-muted">ID y nombre se mantienen en localStorage. Si entran varios usuarios en la página, serán emparejados automáticamente.</div>
        </div>
      </div>
    </div>

    <footer class="text-center small-muted mt-4">CamNext — Demo. Para producción: claves PubNub propias + TURN. </footer>
  </div>

  <!-- PubNub SDK -->
  <script src="https://cdn.pubnub.com/sdk/javascript/pubnub.4.35.0.min.js"></script>
  <script>
  // ---------- CONFIG ----------
  // PubNub demo keys para prototipo (cámbialas por tus keys en producción)
  const pubnub = new PubNub({
    publishKey: 'demo',
    subscribeKey: 'demo',
    uuid: null
  });

  // Canal de lobby y prefijo de señalización
  const LOBBY = 'camnext-lobby-v1';
  const ROOM_PREFIX = 'camnext-room-';

  // ICE config — STUN y ejemplos de TURN públicos (solo ejemplos; para producción usá TURN propio)
  const RTC_CONFIG = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun.services.mozilla.com' },
      // Ejemplo de TURN público (openrelay) — puede ayudar en algunos casos:
      { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' }
      // Si tenés credenciales numb.viagenie, agregalas aquí:
      // { urls: 'turn:numb.viagenie.ca', username: 'TU_USER', credential: 'TU_PASS' }
    ]
  };

  // ---------- UTILIDADES ----------
  function uid(len=8){
    return crypto.getRandomValues(new Uint8Array(len)).reduce((s,v)=> s + v.toString(16).padStart(2,'0'), '').slice(0,16);
  }

  const localKey = 'camnext:user';
  let localUser = JSON.parse(localStorage.getItem(localKey) || 'null');
  if(!localUser){ localUser = { id: uid(), name: 'User-'+Math.floor(Math.random()*9000+1000) }; localStorage.setItem(localKey, JSON.stringify(localUser)); }
  pubnub.setUUID(localUser.id);

  // UI refs
  const uidBadge = document.getElementById('uidBadge');
  const nameInput = document.getElementById('nameInput');
  const saveName = document.getElementById('saveName');
  const findBtn = document.getElementById('findBtn');
  const roomLabel = document.getElementById('roomLabel');
  const chatBox = document.getElementById('chatBox');
  const chatInput = document.getElementById('chatInput');
  const sendBtn = document.getElementById('sendBtn');
  const localVideo = document.getElementById('localVideo');
  const remoteVideo = document.getElementById('remoteVideo');
  const toggleCam = document.getElementById('toggleCam');
  const toggleMic = document.getElementById('toggleMic');
  const shareScreen = document.getElementById('shareScreen');
  const sendFileBtn = document.getElementById('sendFileBtn');
  const fileInput = document.getElementById('fileInput');

  uidBadge.textContent = `${localUser.name} — ${localUser.id.slice(0,8)}`;
  nameInput.value = localUser.name;

  saveName.addEventListener('click', ()=>{ localUser.name = nameInput.value.trim() || localUser.name; localStorage.setItem(localKey, JSON.stringify(localUser)); uidBadge.textContent = `${localUser.name} — ${localUser.id.slice(0,8)}`; });

  // ---------- MEDIA ----------
  let localStream = null;
  async function startLocalMedia(){
    try{
      localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
      localVideo.srcObject = localStream;
    }catch(e){
      appendSystem('No se pudo acceder a cámara/mic. Revisá permisos.');
      console.warn(e);
    }
  }
  startLocalMedia();

  toggleCam.addEventListener('click', ()=>{ if(!localStream) return; const t = localStream.getVideoTracks()[0]; if(t) t.enabled = !t.enabled; toggleCam.textContent = t && t.enabled ? 'Cam ON' : 'Cam OFF';});
  toggleMic.addEventListener('click', ()=>{ if(!localStream) return; const t = localStream.getAudioTracks()[0]; if(t) t.enabled = !t.enabled; toggleMic.textContent = t && t.enabled ? 'Mic ON' : 'Mic OFF';});

  shareScreen.addEventListener('click', async ()=>{
    try{
      const s = await navigator.mediaDevices.getDisplayMedia({video:true});
      const track = s.getVideoTracks()[0];
      if(window.pc){
        const sender = pc.getSenders().find(x=>x.track && x.track.kind==='video');
        if(sender) sender.replaceTrack(track);
      }
      localVideo.srcObject = s;
      track.onended = ()=>{ if(localStream) localVideo.srcObject = localStream; };
    }catch(e){ console.warn('share cancelled', e); }
  });

  // ---------- MATCHMAKING (LOBBY) ----------
  // Estado local
  let pc = null;
  let dc = null;
  let currentRoom = null;
  let incomingFile = null;
  let waitingForPair = false;

  // Nos subscribimos al lobby con presence ON para recibir eventos en tiempo real
  // Nota: para que Presence funcione se necesita que la key tenga la feature habilitada; las demo-keys pueden tener limitaciones.
  function subscribeLobby(){
    try{
      pubnub.addListener({
        message: function(evt){ /* no usamos mensajes del lobby aquí */ },
        presence: function(evt){
          // evt.action: 'join', 'leave', 'timeout'
          if(evt.action === 'join' || evt.action === 'state-change'){
            // si alguien se sumó y no estamos emparejados, intentamos emparejar
            const otherId = evt.uuid;
            if(otherId && otherId !== localUser.id && !currentRoom && !waitingForPair){
              // start pairing (we'll only start if deterministic rule allows it)
              attemptPairWith(otherId);
            }
          }
        }
      });

      // subscribe with presence option (receive presence events)
      pubnub.subscribe({channels:[LOBBY], withPresence:true});
    }catch(e){ console.warn('subscribeLobby error', e); }
  }
  subscribeLobby();

  async function announceAvailable(){
    // Broadcast a short 'available' message to help discovery (also leaves a published message)
    try{
      await pubnub.publish({channel: LOBBY, message:{ type:'available', id: localUser.id, name: localUser.name, ts: Date.now() }});
    }catch(e){ console.warn('announceAvailable', e); }
  }

  // On load, call hereNow to attempt immediate matching with existing occupants
  async function scanLobbyNow(){
    try{
      const res = await new Promise((res,rej)=>{
        pubnub.hereNow({ channels:[LOBBY], includeUUIDs:true, includeState:false }, (status, response)=> {
          if(status.error) return rej(status);
          res(response);
        });
      });
      const occ = (res && res.channels && res.channels[LOBBY] && res.channels[LOBBY].occupants) ? res.channels[LOBBY].occupants : [];
      const candidates = occ.map(o=>o.uuid).filter(id=>id && id !== localUser.id);
      if(candidates.length > 0 && !currentRoom){
        // pick a random candidate and try pair
        const otherId = candidates[Math.floor(Math.random()*candidates.length)];
        attemptPairWith(otherId);
      }
    }catch(e){ console.warn('scanLobbyNow', e); }
  }

  // Regla determinista: solo uno (el que tenga UUID lexicográficamente menor) iniciará la oferta
  function attemptPairWith(otherId){
    if(currentRoom) return;
    // avoid racing multiple attempts
    waitingForPair = true;
    // small debounce in case multiple presence events arrive
    setTimeout(()=>{ waitingForPair = false; }, 1500);

    // deterministically create room id
    const roomId = [localUser.id, otherId].sort().join('-');
    // Who will create the offer? define starter as the lexicographically smaller id
    const amIStarter = localUser.id < otherId;
    startSignaling(roomId, otherId, amIStarter);
  }

  // Periodically announce availability (keeps lobby fresh)
  setInterval(()=> announceAvailable(), 4000);
  // Also do immediate announce & scan on load
  announceAvailable();
  scanLobbyNow();

  // ---------- SIGNALING + WEBRTC ----------
  function startSignaling(roomId, otherId, amIStarter){
    if(currentRoom) return;
    currentRoom = roomId;
    roomLabel.textContent = roomId;
    appendSystem(`Iniciando señalización (${amIStarter ? 'starter' : 'waiter'}) con ${otherId} en ${roomId}`);

    const channel = ROOM_PREFIX + roomId;

    // subscribe to the room channel
    pubnub.subscribe({channels:[channel]});

    // set a one-time listener for messages for this room channel
    const roomListener = {
      message: function(evt){
        if(evt.channel !== channel) return;
        const m = evt.message;
        if(!m || m.from === localUser.id) return;
        if(m.type === 'offer') handleRemoteOffer(m.sdp, m.from);
        else if(m.type === 'answer') handleRemoteAnswer(m.sdp);
        else if(m.type === 'candidate') handleRemoteCandidate(m.cand);
      }
    };
    pubnub.addListener(roomListener);

    // build RTCPeerConnection
    pc = new RTCPeerConnection(RTC_CONFIG);
    pc.onicecandidate = e => { if(e.candidate) pubnub.publish({channel, message:{type:'candidate', cand: e.candidate, from: localUser.id}}); };
    pc.ontrack = e => { remoteVideo.srcObject = e.streams[0]; };
    pc.onconnectionstatechange = ()=> {
      if(!pc) return;
      appendSystem('Estado conexión: ' + pc.connectionState);
      if(pc.connectionState === 'connected') {
        appendSystem('Conexión P2P establecida');
      } else if(pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
        // cleanup if closed
      }
    };

    // attach local tracks
    if(localStream) localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    // Data channel
    dc = pc.createDataChannel('camnext-data');
    setupDataChannel(dc);
    pc.ondatachannel = e => { dc = e.channel; setupDataChannel(dc); };

    // If i'm starter -> create offer and publish
    (async ()=>{
      try{
        if(amIStarter){
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          await pubnub.publish({channel, message:{type:'offer', sdp: offer, from: localUser.id}});
        } else {
          // If not starter: wait for incoming offer (handled by listener)
          appendSystem('Esperando oferta remota...');
        }
      }catch(e){ console.warn('startSignaling err', e); appendSystem('Error iniciando offer'); }
    })();
  }

  async function handleRemoteOffer(sdp, from){
    try{
      // if no pc yet (edge case), start skeleton connection
      if(!pc){
        // create peer connection without deciding to be starter (we'll respond with answer)
        startSignaling(currentRoom || [localUser.id, from].sort().join('-'), from, false);
      }
      await pc.setRemoteDescription(new RTCSessionDescription(sdp));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      const channel = ROOM_PREFIX + (currentRoom || [localUser.id, from].sort().join('-'));
      await pubnub.publish({channel, message:{type:'answer', sdp: answer, from: localUser.id}});
    }catch(e){ console.warn('handleRemoteOffer', e); }
  }

  async function handleRemoteAnswer(sdp){
    try{ await pc.setRemoteDescription(new RTCSessionDescription(sdp)); }catch(e){ console.warn(e); }
  }

  async function handleRemoteCandidate(cand){
    try{ await pc.addIceCandidate(new RTCIceCandidate(cand)); }catch(e){ console.warn('candidate add failed', e); }
  }

  function setupDataChannel(channel){
    channel.binaryType = 'arraybuffer';
    channel.onopen = ()=> appendSystem('Canal de datos abierto (P2P)');
    channel.onmessage = e=>{
      try{
        if(typeof e.data === 'string'){
          const json = JSON.parse(e.data);
          if(json.type === 'chat') appendChat(json.text, json.name || 'Anon');
          else if(json.type === 'file-meta'){ incomingFile = { meta: json.meta, chunks: [], received: 0 }; appendSystem('Recibiendo archivo: ' + json.meta.name); }
          else if(json.type === 'file-end'){ const blob = new Blob(incomingFile.chunks); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = incomingFile.meta.name; a.textContent = `Descargar ${incomingFile.meta.name}`; a.className='d-block file-item'; chatBox.appendChild(a); chatBox.scrollTop = chatBox.scrollHeight; incomingFile = null; }
        } else {
          if(incomingFile) incomingFile.chunks.push(e.data);
        }
      }catch(err){ console.warn(err); }
    };
    channel.onclose = ()=> appendSystem('Canal de datos cerrado');
  }

  // ---------- CHAT + FILE UI ----------
  sendBtn.addEventListener('click', ()=>{ if(chatInput.value.trim()) sendChat(chatInput.value.trim()); });
  chatInput.addEventListener('keydown', e=>{ if(e.key === 'Enter') sendBtn.click(); });

  function sendChat(text){
    const payload = { type:'chat', text, name: localUser.name };
    if(dc && dc.readyState === 'open'){ dc.send(JSON.stringify(payload)); appendChat(text, 'Yo'); }
    else appendSystem('No estás conectado por P2P aún');
  }

  sendFileBtn.addEventListener('click', async ()=>{
    const file = fileInput.files[0]; if(!file) return alert('Elegí un archivo');
    if(dc && dc.readyState === 'open'){
      dc.send(JSON.stringify({ type:'file-meta', meta: { name: file.name, size: file.size, type: file.type } }));
      const chunkSize = 32*1024; let offset = 0;
      const reader = new FileReader();
      reader.onload = e => {
        dc.send(e.target.result);
        offset += e.target.result.byteLength;
        if(offset < file.size) readSlice(offset);
        else dc.send(JSON.stringify({ type:'file-end' }));
      };
      function readSlice(o){ const s = file.slice(o, o+chunkSize); reader.readAsArrayBuffer(s); }
      readSlice(0);
      appendSystem('Enviando archivo: ' + file.name);
    } else alert('Conexión P2P no disponible');
  });

  // ---------- PASS / STOP ----------
  findBtn.addEventListener('click', ()=>{ findBtn.disabled = true; findBtn.textContent='Buscando...'; announceAvailable(); scanLobbyNow(); setTimeout(()=>{ findBtn.disabled=false; findBtn.textContent='Buscar (auto)'; }, 2000); });

  const passBtn = document.getElementById('passBtn'), stopBtn = document.getElementById('stopBtn');
  passBtn.addEventListener('click', ()=>{ cleanup(); announceAvailable(); scanLobbyNow();});
  stopBtn.addEventListener('click', ()=>{ cleanup(); });

  function cleanup(){
    try{ if(dc) dc.close(); }catch(e){}
    try{ if(pc) pc.close(); }catch(e){}
    dc = null; pc = null; currentRoom = null; roomLabel.textContent = 'No conectado'; chatBox.innerHTML = '';
    // unsubscribe room channels to avoid lingering listeners
    try{ pubnub.unsubscribeAll(); subscribeLobby(); }catch(e){}
  }

  // ---------- UI helpers ----------
  function appendSystem(txt){ const el = document.createElement('div'); el.className='small-muted'; el.textContent = txt; chatBox.appendChild(el); chatBox.scrollTop = chatBox.scrollHeight; }
  function appendChat(txt, name='Otro'){ const d = document.createElement('div'); d.className='mb-2'; d.innerHTML = `<strong>${name}:</strong> ${escapeHtml(txt)}`; chatBox.appendChild(d); chatBox.scrollTop = chatBox.scrollHeight; }
  function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#039;"}[c])); }

  // ---------- final: subscribe lobby & cleanup ----------
  window.addEventListener('beforeunload', ()=>{ try{ pubnub.publish({channel: LOBBY, message:{type:'leave', id: localUser.id}}); }catch(e){} });

  </script>
</body>
</html>
