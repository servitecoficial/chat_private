<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CamNext — Aleatorio P2P (Auto-match)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <style>
    :root { --accent: #0d6efd; }
    body { background: #f6f7fb; font-family: Arial, sans-serif; }
    .app { max-width: 1100px; margin: 24px auto; }
    .video-wrap { background:#111; border-radius:12px; padding:8px; }
    video { width:100%; height:auto; border-radius:8px; background:#000; }
    .user-badge { font-weight:600; }
    .chat-box { height:320px; overflow:auto; background:#fff; padding:12px; border-radius:8px; border:1px solid #e6e6e6; }
    .small-muted { font-size:.85rem; color:#6c757d; }
    .file-item { font-size:.9rem; }
    .btn-sm { font-size:.75rem; }
    .ad-container { margin-top:20px; text-align:center; border-top:1px solid #ccc; padding-top:10px; }
  </style>
</head>
<body>
  <div class="container app">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h2 class="mb-0">CamNext <small class="small-muted">— Emparejado automático (demo)</small></h2>
      <div><span id="uidBadge" class="badge bg-secondary user-badge">Generando...</span></div>
    </div>

    <div class="row g-3">
      <div class="col-md-7">
        <div class="video-wrap mb-3">
          <div class="row g-2">
            <div class="col-6">
              <label class="small-muted">Tu cámara</label>
              <video id="localVideo" autoplay muted playsinline></video>
              <div class="d-flex gap-2 mt-2">
                <button id="toggleCam" class="btn btn-sm btn-outline-primary">Cam</button>
                <button id="toggleMic" class="btn btn-sm btn-outline-primary">Mic</button>
                <button id="shareScreen" class="btn btn-sm btn-outline-secondary">Compartir pantalla</button>
              </div>
            </div>
            <div class="col-6">
              <label class="small-muted">Conectado a</label>
              <video id="remoteVideo" autoplay playsinline></video>
              <div class="d-flex gap-2 mt-2">
                <button id="passBtn" class="btn btn-sm btn-danger">Siguiente</button>
                <button id="stopBtn" class="btn btn-sm btn-outline-danger">Desconectar</button>
              </div>
            </div>
          </div>
        </div>

        <div class="card p-3 mb-3">
          <div class="d-flex gap-2 align-items-center">
            <input id="nameInput" class="form-control form-control-sm" placeholder="Tu nombre (opcional)" />
            <button id="saveName" class="btn btn-sm btn-primary">Guardar</button>
            <button id="findBtn" class="btn btn-sm btn-success">Buscar (auto)</button>
          </div>
          <div class="mt-2 small-muted">El sistema intentará emparejarte automáticamente con la primera persona disponible.</div>
        </div>
      </div>

      <div class="col-md-5">
        <div class="card p-3 mb-3">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <strong>Chat & Archivos</strong>
            <small class="small-muted" id="roomLabel">No conectado</small>
          </div>
          <div id="chatBox" class="chat-box mb-2"></div>

          <div class="d-flex gap-2">
            <input id="chatInput" class="form-control form-control-sm" placeholder="Escribí algo..." />
            <button id="sendBtn" class="btn btn-sm btn-primary">Enviar</button>
          </div>

          <div class="d-flex gap-2 mt-2">
            <input type="file" id="fileInput" class="form-control form-control-sm" />
            <button id="sendFileBtn" class="btn btn-sm btn-outline-primary">Enviar archivo</button>
          </div>

          <div class="mt-2 small-muted">En producción reemplazá las claves demo y agregá un TURN confiable.</div>
        </div>

        <div class="card p-3">
          <strong>Estado</strong>
          <div class="mt-2 small-muted">ID y nombre se mantienen en localStorage. Si entran varios usuarios en la página, serán emparejados automáticamente.</div>
        </div>

        <!-- Publicidad -->
        <div class="ad-container" id="adContainer">
          <!-- Aquí se puede inyectar el script de publicidad -->
        </div>
      </div>
    </div>

    <footer class="text-center small-muted mt-4">CamNext — Demo. Para producción: claves PubNub propias + TURN. </footer>
  </div>

  <!-- PubNub SDK -->
  <script src="https://cdn.pubnub.com/sdk/javascript/pubnub.4.35.0.min.js"></script>
  <script>
  // ---------- CONFIG ----------
  const pubnub = new PubNub({ publishKey: 'demo', subscribeKey: 'demo', uuid: null });
  const LOBBY = 'camnext-lobby-v1';
  const ROOM_PREFIX = 'camnext-room-';
  const RTC_CONFIG = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun.services.mozilla.com' },
      { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' }
    ]
  };

  function uid(len=8){ return crypto.getRandomValues(new Uint8Array(len)).reduce((s,v)=> s + v.toString(16).padStart(2,'0'), '').slice(0,16); }
  const localKey = 'camnext:user';
  let localUser = JSON.parse(localStorage.getItem(localKey) || 'null');
  if(!localUser){ localUser = { id: uid(), name: 'User-'+Math.floor(Math.random()*9000+1000) }; localStorage.setItem(localKey, JSON.stringify(localUser)); }
  pubnub.setUUID(localUser.id);

  // UI refs
  const uidBadge = document.getElementById('uidBadge');
  const nameInput = document.getElementById('nameInput');
  const saveName = document.getElementById('saveName');
  const findBtn = document.getElementById('findBtn');
  const roomLabel = document.getElementById('roomLabel');
  const chatBox = document.getElementById('chatBox');
  const chatInput = document.getElementById('chatInput');
  const sendBtn = document.getElementById('sendBtn');
  const localVideo = document.getElementById('localVideo');
  const remoteVideo = document.getElementById('remoteVideo');
  const toggleCam = document.getElementById('toggleCam');
  const toggleMic = document.getElementById('toggleMic');
  const shareScreen = document.getElementById('shareScreen');
  const sendFileBtn = document.getElementById('sendFileBtn');
  const fileInput = document.getElementById('fileInput');

  uidBadge.textContent = `${localUser.name} — ${localUser.id.slice(0,8)}`;
  nameInput.value = localUser.name;

  saveName.addEventListener('click', ()=>{ 
    localUser.name = nameInput.value.trim() || localUser.name; 
    localStorage.setItem(localKey, JSON.stringify(localUser)); 
    uidBadge.textContent = `${localUser.name} — ${localUser.id.slice(0,8)}`; 
  });

  // ---------- MEDIA ----------
  let localStream = null;
  let remoteStream = null;
  async function startLocalMedia(){
    try{
      localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
      localVideo.srcObject = localStream;
    }catch(e){
      appendSystem('No se pudo acceder a cámara/mic. Revisá permisos.');
      console.warn(e);
    }
  }
  startLocalMedia();

  toggleCam.addEventListener('click', ()=>{ 
    if(!localStream) return; 
    const t = localStream.getVideoTracks()[0]; 
    if(t) t.enabled = !t.enabled; 
    toggleCam.textContent = t && t.enabled ? 'Cam ON' : 'Cam OFF';
  });
  toggleMic.addEventListener('click', ()=>{ 
    if(!localStream) return; 
    const t = localStream.getAudioTracks()[0]; 
    if(t) t.enabled = !t.enabled; 
    toggleMic.textContent = t && t.enabled ? 'Mic ON' : 'Mic OFF';
  });
  shareScreen.addEventListener('click', async ()=>{
    try{
      const s = await navigator.mediaDevices.getDisplayMedia({video:true});
      const track = s.getVideoTracks()[0];
      if(pc){
        const sender = pc.getSenders().find(x=>x.track && x.track.kind==='video');
        if(sender) sender.replaceTrack(track);
      }
      localVideo.srcObject = s;
      track.onended = ()=>{ if(localStream) localVideo.srcObject = localStream; };
    }catch(e){ console.warn('share cancelled', e); }
  });

  // ---------- MATCHMAKING ----------
  let pc = null, dc = null, currentRoom = null, incomingFile = null, waitingForPair = false;

  function subscribeLobby(){
    try{
      pubnub.addListener({
        message: ()=>{},
        presence: function(evt){
          const otherId = evt.uuid;
          if(otherId && otherId !== localUser.id && !currentRoom && !waitingForPair){
            attemptPairWith(otherId);
          }
        }
      });
      pubnub.subscribe({channels:[LOBBY], withPresence:true});
    }catch(e){ console.warn(e); }
  }
  subscribeLobby();

  async function announceAvailable(){
    try{ await pubnub.publish({channel: LOBBY, message:{ type:'available', id: localUser.id, name: localUser.name, ts: Date.now() }}); }
    catch(e){ console.warn(e); }
  }
  async function scanLobbyNow(){
    try{
      const res = await new Promise((res,rej)=>{ pubnub.hereNow({ channels:[LOBBY], includeUUIDs:true }, (status, response)=>{ if(status.error) return rej(status); res(response); }); });
      const occ = (res?.channels?.[LOBBY]?.occupants) || [];
      const candidates = occ.map(o=>o.uuid).filter(id=>id !== localUser.id);
      if(candidates.length > 0 && !currentRoom){
        const otherId = candidates[Math.floor(Math.random()*candidates.length)];
        attemptPairWith(otherId);
      }
    }catch(e){ console.warn(e); }
  }

  function attemptPairWith(otherId){
    if(currentRoom) return;
    waitingForPair = true;
    setTimeout(()=>{ waitingForPair=false; }, 1500);
    const roomId = [localUser.id, otherId].sort().join('-');
    const amIStarter = localUser.id < otherId;
    startSignaling(roomId, otherId, amIStarter);
  }

  setInterval(()=> announceAvailable(), 4000);
  announceAvailable();
  scanLobbyNow();

  // ---------- SIGNALING + WEBRTC ----------
  function startSignaling(roomId, otherId, amIStarter){
    if(currentRoom) return;
    currentRoom = roomId;
    roomLabel.textContent = roomId;
    appendSystem(`Iniciando señalización (${amIStarter ? 'starter' : 'waiter'}) con ${otherId} en ${roomId}`);
    const channel = ROOM_PREFIX + roomId;
    pubnub.subscribe({channels:[channel]});

    const roomListener = {
      message: function(evt){
        if(evt.channel !== channel) return;
        const m = evt.message; if(!m || m.from === localUser.id) return;
        if(m.type==='offer') handleRemoteOffer(m.sdp, m.from);
        else if(m.type==='answer') handleRemoteAnswer(m.sdp);
        else if(m.type==='candidate') handleRemoteCandidate(m.cand);
      }
    };
    pubnub.addListener(roomListener);

    pc = new RTCPeerConnection(RTC_CONFIG);
    if(localStream) localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));
    remoteStream = new MediaStream();
    remoteVideo.srcObject = remoteStream;

    pc.ontrack = e => { e.streams[0].getTracks().forEach(track=>remoteStream.addTrack(track)); };
    pc.onicecandidate = e => { if(e.candidate) pubnub.publish({channel, message:{type:'candidate', cand:e.candidate, from:localUser.id}}); };
    pc.onconnectionstatechange = ()=>{ if(!pc) return; appendSystem('Estado conexión: ' + pc.connectionState); };

    dc = pc.createDataChannel('camnext-data');
    setupDataChannel(dc);
    pc.ondatachannel = e=>{ dc = e.channel; setupDataChannel(dc); };

    (async ()=>{
      try{
        if(amIStarter){
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          await pubnub.publish({channel, message:{type:'offer', sdp:offer, from:localUser.id}});
        } else { appendSystem('Esperando oferta remota...'); }
      }catch(e){ console.warn(e); appendSystem('Error iniciando offer'); }
    })();
  }

  async function handleRemoteOffer(sdp, from){
    try{
      if(!pc){ startSignaling(currentRoom || [localUser.id, from].sort().join('-'), from, false); }
      await pc.setRemoteDescription(new RTCSessionDescription(sdp));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      const channel = ROOM_PREFIX + (currentRoom || [localUser.id, from].sort().join('-'));
      await pubnub.publish({channel, message:{type:'answer', sdp:answer, from:localUser.id}});
    }catch(e){ console.warn(e); }
  }
  async function handleRemoteAnswer(sdp){ try{ await pc.setRemoteDescription(new RTCSessionDescription(sdp)); }catch(e){ console.warn(e); } }
  async function handleRemoteCandidate(cand){ try{ await pc.addIceCandidate(new RTCIceCandidate(cand)); }catch(e){ console.warn(e); } }

  function setupDataChannel(channel){
    channel.binaryType='arraybuffer';
    channel.onopen = ()=> appendSystem('Canal de datos abierto (P2P)');
    channel.onmessage = e=>{
      try{
        if(typeof e.data==='string'){
          const json = JSON.parse(e.data);
          if(json.type==='chat'){ appendChat(json.text, json.name || 'Anon'); }
          else if(json.type==='file-meta'){ incomingFile={meta:json.meta,chunks:[],received:0}; appendSystem('Recibiendo archivo: '+json.meta.name); }
          else if(json.type==='file-end'){ 
            const blob = new Blob(incomingFile.chunks); 
            const url = URL.createObjectURL(blob); 
            const a = document.createElement('a'); a.href=url; a.download=incomingFile.meta.name; a.textContent=`Descargar ${incomingFile.meta.name}`; a.className='d-block file-item'; 
            chatBox.appendChild(a); chatBox.scrollTop=chatBox.scrollHeight; incomingFile=null;
          }
        } else if(incomingFile){ incomingFile.chunks.push(e.data); }
      }catch(err){ console.warn(err); }
    };
    channel.onclose = ()=> appendSystem('Canal de datos cerrado');
  }

  // ---------- CHAT + FILE UI ----------
  sendBtn.addEventListener('click', ()=>{ 
    if(chatInput.value.trim()) sendChat(chatInput.value.trim()); 
    chatInput.value=''; 
    chatInput.focus();
  });
  chatInput.addEventListener('keydown', e=>{ if(e.key==='Enter') sendBtn.click(); });

  function sendChat(text){
    const payload={type:'chat', text, name:localUser.name};
    if(dc && dc.readyState==='open'){ dc.send(JSON.stringify(payload)); appendChat(text,'Yo'); }
    else appendSystem('No estás conectado por P2P aún');
  }

  sendFileBtn.addEventListener('click', async ()=>{
    const file=fileInput.files[0]; if(!file) return alert('Elegí un archivo');
    if(dc && dc.readyState==='open'){
      dc.send(JSON.stringify({type:'file-meta', meta:{name:file.name, size:file.size, type:file.type}}));
      const chunkSize=32*1024; let offset=0; const reader=new FileReader();
      reader.onload=e=>{ dc.send(e.target.result); offset+=e.target.result.byteLength; if(offset<file.size) readSlice(offset); else dc.send(JSON.stringify({type:'file-end'})); };
      function readSlice(o){ const s=file.slice(o,o+chunkSize); reader.readAsArrayBuffer(s); }
      readSlice(0);
      appendSystem('Enviando archivo: '+file.name);
    } else alert('Conexión P2P no disponible');
  });

  // ---------- PASS / STOP ----------
  findBtn.addEventListener('click', ()=>{
    findBtn.disabled=true; findBtn.textContent='Buscando...'; announceAvailable(); scanLobbyNow(); 
    setTimeout(()=>{ findBtn.disabled=false; findBtn.textContent='Buscar (auto)'; },2000); 
  });

  const passBtn=document.getElementById('passBtn'), stopBtn=document.getElementById('stopBtn');
  passBtn.addEventListener('click', ()=>{ cleanup(); announceAvailable(); scanLobbyNow(); });
  stopBtn.addEventListener('click', ()=> cleanup());

  function cleanup(){
    if(pc){ pc.close(); pc=null; }
    if(dc){ dc.close(); dc=null; }
    remoteVideo.srcObject=null;
    remoteStream=null;
    currentRoom=null;
    roomLabel.textContent='No conectado';
    appendSystem('Conexión finalizada.');
  }

  // ---------- HELPERS ----------
  function appendSystem(txt){ const el=document.createElement('div'); el.className='small-muted'; el.textContent='[SYS] '+txt; chatBox.appendChild(el); chatBox.scrollTop=chatBox.scrollHeight; }
  function appendChat(txt,who){ const el=document.createElement('div'); el.innerHTML=`<b>${who}:</b> ${txt}`; chatBox.appendChild(el); chatBox.scrollTop=chatBox.scrollHeight; }
  </script>
</body>
</html>
